use cosmwasm_std::{dyn_contract_err, ReadonlyStorage, StdResult, Storage};

use crate::error::GoResult;
use crate::memory::Buffer;

// this represents something passed in from the caller side of FFI
#[repr(C)]
pub struct db_t {
    _private: [u8; 0],
}

// These functions should return GoResult but because we don't trust them here, we treat the return value as i32
// These functions should return GoResult but because we don't trust them here, we treat the return value as i32
// and then check it when converting to GoResult manually
#[repr(C)]
pub struct DB_vtable {
    pub read_db: extern "C" fn(*mut db_t, Buffer, *mut Buffer) -> i32,
    pub write_db: extern "C" fn(*mut db_t, Buffer, Buffer) -> i32,
    pub remove_db: extern "C" fn(*mut db_t, Buffer) -> i32,
}

#[repr(C)]
pub struct DB {
    pub state: *mut db_t,
    pub vtable: DB_vtable,
}

impl ReadonlyStorage for DB {
    fn get(&self, key: &[u8]) -> StdResult<Option<Vec<u8>>> {
        let key = Buffer::from_vec(key.to_vec());
        let mut result_buf = Buffer::default();
        let go_result: GoResult =
            (self.vtable.read_db)(self.state, key, &mut result_buf as *mut Buffer).into();
        let _key = unsafe { key.consume() };
        if !go_result.is_ok() {
            // TODO: add the key to the message?
            // panic!("Go panicked while writing key {:?}", key);
            return dyn_contract_err(go_result.to_string());
        }

        if result_buf.ptr.is_null() {
            return Ok(None);
        }

        // We initialize `result_buf` with a null pointer. if it is not null,
        // that means it was initialized by the go code, with values generated by `memory::allocate_rust`
        Ok(unsafe { Some(result_buf.consume()) })
    }
}

impl Storage for DB {
    fn set(&mut self, key: &[u8], value: &[u8]) -> StdResult<()> {
        let key = Buffer::from_vec(key.to_vec());
        let value = Buffer::from_vec(value.to_vec());
        // caller will free input
        let go_result: GoResult = (self.vtable.write_db)(self.state, key, value).into();
        let _key = unsafe { key.consume() };
        let _value = unsafe { value.consume() };
        if !go_result.is_ok() {
            // TODO: add the key to the message?
            // panic!("Go panicked while writing key {:?}", key);
            dyn_contract_err(go_result.to_string())
        } else {
            Ok(())
        }
    }

    fn remove(&mut self, key: &[u8]) -> StdResult<()> {
        let key = Buffer::from_vec(key.to_vec());
        // caller will free input
        let go_result: GoResult = (self.vtable.remove_db)(self.state, key).into();
        let _key = unsafe { key.consume() };
        if !go_result.is_ok() {
            // TODO: add the key to the message?
            // panic!("Go panicked while writing key {:?}", key);
            dyn_contract_err(go_result.to_string())
        } else {
            Ok(())
        }
    }
}
